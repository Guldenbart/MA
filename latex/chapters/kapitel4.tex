% -------------------------------------------------------------------
% Masterarbeit
% Kapitel 4: Implementierungstechniken
% Autor: Daniel Fritz
% Datum: 09.04.2016
% -------------------------------------------------------------------

\chapter{Implementierungstechniken}\label{chp:4:implementierungstechniken}
Dieses Kapitel stellt dar, aus welchen Teilen die Implementierung der Sprache aufgebaut ist. Ihre Funktion, ihre Implementierung und mögliche Alternativen werden gezeigt. Aufgrund des Inhalts dieser Arbeit beschränken sich Beispiele und Beschreibungen auch auf Java. Die Konzepte können jedoch auch auf andere Programmiersprachen übertragen werden. In den Abschnitten \ref{sct:4.1:eigenschaften} und \ref{sct:4.2:teile} werden allgemeine Techniken vorgestellt, die oft bei der Implementierung einer Programmiersprache, insbesondere einer internen DSL verwendet werden. Die restlichen Abschnitte dieses Kapitels widmen sich der Implementierungen im Rahmen dieser Abschlussarbeit.

\section{Eigenschaften der Sprache}\label{sct:4.1:eigenschaften}
Der Bezug auf ein bestimmtes Arbeitsgebiet ist für eine Domänenspezifische Sprache obligatorisch. Es gibt noch weitere Eigenschaften\todo{anderes Wort?}, die häufig mit internen DSLs in Verbindung gebracht werden, auch wenn sie nicht zwingend erforderlich sind. Jedoch steigern sie die Lesbarkeit der Sprache und die Produktivität bei der Arbeit mit ihr. An dieser Stelle sollen diese Eigenschaften kurz beschrieben werden und beispielhaft \todo{richtiges Wort?} erklärt werden, wie man sie erreicht.

\subsection{Method Chaining}\label{ssct:4.1.1:chaining}
Method Chaining, das Aneinanderreihen von Methoden, wird von vielen direkt mit dem Aussehen einer internen DSL verbunden. Es ist zwar nicht zwingend notwendig, Method Chaining in einer internen DSL zu verwenden, jedoch ist es eine sehr nützliche Technik mit der man den Sprachfluss und die Lesbarkeit einer Sprache deutlich verbessern kann\cite{book:fowlerDSL}. Ein kurzes Beispiel soll dies verdeutlichen.

Dafür nehmen wir an, dass eine Klasse \emph{Rezept} alle Zutaten für ein bestimmtes Rezept hält. Da eine Vielzahl an Zutaten möglich ist, aber immer nur ein paar wenige für ein einzelnes Rezept nötig sind, werden sie der Klasse nicht per Konstruktor sondern per set-Methode übergeben. Normalerweise würde das folgendermaßen aussehen (alle Code-Beispiele sind in Java):\\

\begin{lstlisting}[caption=Erstellung eines Rezepts auf normale Weise]
	Recipe cake = new Recipe();
	cake.setButter(200);
	cake.setSugar(300);
	cake.setEggs(4);
	cake.setMilk(200);
	cake.setFlour(500);
\end{lstlisting}

\noindent
Dasselbe Rezept würde man mithilfe von Method Chaining auf die folgende Weise zusammenstellen:\\


\begin{lstlisting}[caption=Erstellung desselben Rezepts mit Method Chaining]
	Recipe cake = new Recipe();
	cake.butter(200).sugar(300).eggs(4).milk(200).flour(500);
\end{lstlisting}

Um dieses Verhalten zu erreichen, müssen die einzelnen setter-Methoden anders als gewohnt implementiert werden. Üblicherweise würde eine Methode der Klasse so aussehen:\\

\begin{lstlisting}[caption={set-Methode, implementiert zur Aneinaderreihung}]
	public Recipe butter(int butterInGrams) {
		this.butter = butterInGrams;
	}
\end{lstlisting}

Um sie verketten zu können, müsste man dieselbe Methode folgendermaßen implementieren:\\

\begin{lstlisting}[caption=set-Methode in der üblichen Implementierung]
	public void setButter(int butterInGrams) {
		this.butter = butterInGrams;
	}
\end{lstlisting}

\subsection{Method Nesting}\label{ssct:4.1.2:nesting}
Method Nesting beschreibt das Verschachteln von Funktionen um hierarchische Strukturen abzubilden, insbesondere rekursive Aufrufe\cite{book:fowlerDSL}, \cite{vl:drachen:teil3}. Dies wird erreicht, indem Rückgabewerte von Methoden als Argumente von Methoden einsetzbar sind.

In diesem Beispiel nehmen wir eine Sprache an, die Flächen beschreibt. Die Form der Fläche wird durch die Koordinaten einzelner Punkte angegeben. Der Code zeigt eine Fläche, die durch das Zusammensetzen zweier Flächen entsteht:

\begin{lstlisting}[caption=beispielhafte Verwendung von Method Nesting]
	Shape square = shape(point(0,0).point(0,1).point(1,1).point(1,0));
	Shape triangle = shape(point(0,1).point(0.5,2).point(1,1));
	
	Shape combine = shape(square.triangle);
\end{lstlisting}

\subsection{Object Scoping}\label{ssct:4.1.3:scoping}
Object Scoping erlaubt es, verkettete Methoden und die Zwischenergebnisse, welche bei der Verwendung auftreten, in einem Hostobjekt zu speichern. Die Alternative dazu ist das Speichern in globalen Variablen, was stets vermieden werden sollte.
\\ \\
Zusammen mit Method Chaining kann Object Scoping dazu verwendet werden, bestimmte Aufrufreihenfolge innerhalb der Sprache festzulegen und so semantisch fehlerhafte oder unsinnige Eingaben bereits bei der Prüfung der statischen Syntax zu unterbinden. Diese Technik wird auch in dieser Abschlussarbeit verwendet (siehe auch\todo{Verweis}).

\section{Datenstrukturen bei der Verarbeitung von Sprachen}\label{sct:4.2:datenstrukturen}\todo{anderer Name?}
Jede Anweisung einer Sprache muss vom Computer \textquotedblleft verstanden\textquotedblright werden, bevor sie weiter verarbeitet werden kann. Nur in den einfachsten Fällen wird aus einer Eingabe direkt eine Ausgabe erzeugt. Ein Beispiel hierfür ist das Umwandeln eines Wiki-Markup-Formats in html\cite{book:parrLang}.
Damit ein Computer eine nicht-trivialen Anweisung verstehen kann, muss er in Operatoren und Operanden zerlegt werden. Diese müssen in eine Datenstruktur abgelegt werden, die eine für die nachfolgenden Schritte geeignete Struktur aufweist. Zum einen ist wichtig, dass die Reihenfolge der einzelnen Elemente der Anweisung erhalten bleibt, zum anderen müssen die Beziehungen zwischen den Elementen abgebildet werden. Es hat sich herausgestellt, dass Bäume sich dafür am besten eignen\cite{book:parrLang}.

Generell kann hierbei zwischen zwei Arten von Bäumen unterschieden werden. Sie folgen logisch gesehen in der Verarbeitung hintereinander, müssen allerdings nicht immer beide verwendet werden.

Die eine Baum-Struktur ist der sogenannte Parse-Tree oder Syntax-Baum. Er besitzt eine Datenstruktur, in der sich speichern lässt, welche Regeln der Parser auf eine Anweisung angewendet hat und welche Terminalsymbole von ihm erkannt wurden. Innere Knoten des Baums repräsentieren die Regeln, Blätter stehen für Terminalsymbole. Das Prinzip zur Erstellung von Parse-Trees ist einfach und regulär, daher können Syntaxbäume automatisch erstellt werden.\\
Die andere Baum-Struktur ist der abstrakte Syntax-Baum oder Abstract Syntax Tree (kurz: AST). Er repräsentiert, wie der Name vermuten lässt, die abstrakte Syntax-Struktur des Codes. Den AST erhält man, indem man aus dem Parse-Tree alle Knoten entfernt, die nur eine syntaktische und keine semantische Bedeutung haben. Ein einfaches Beispiel für einen solchen Knoten ist das Semikolon am Ende einer Anweisung. Die folgende Abbildung verdeutlicht beispielhaft den Unterschied der beiden Baum-Typen anhand der Anweisung \texttt{x = 0;}:\todo{Bilder von Syntax-Baum und AST}

Der große Vorteil des AST gegenüber dem Parse-Tree ist die Unabhängigkeit von der Syntax der Sprache. Das bedeutet, dass der AST und auch  nachfolgende Verarbeitungsschritte, die auf dem AST operieren, sich nicht ändern, wenn eine Umbenennung einer Regel in der Sprache vorgenommen wird. Außerdem kann der AST schneller als der Parse-Tree durchlaufen werden, weil die Anzahl der Knoten niedriger ist. Allerdings kann der abstrakte Syntax-Baum nicht vollautomatisch aus dem Parse-Tree generiert werden, sondern nur mithilfe von Regeln, die der Kenntnis der Sprach-Semantik bedürfen und diese widerspiegeln.


\section{Implementierung und verwendete Datenstrukturen}\label{ssct:4.3:implementierung}
\todo{text}
Alle nachfolgend beschriebenen Codebeispiele der Implementierung beziehen sich auf eine DSL für arithmetische Ausdrücke. Mit ihr lassen sich Rechnungen in den vier Grundrechenarten in Infix-Notation beschreiben (\texttt{plus()}, \texttt{minus()}, \texttt{times()}, \texttt{divided}). Ein Ausdruck wird mit \texttt{begin()} eröffnet und mit \texttt{end()} abgeschlossen. Das erste Element eines Ausdrucks wird mit der Methode \texttt{expr()} gefasst.

\subsection{Definition einer Grammatik durch Interfaces}\label{ssct:4.3.1:grammatik}
Der erste Schritt bei der Implementierung einer Sprache ist das Festlegen der Grammatik. Dabei soll es, wie in Abschnitt \ref{ssct:4.1.3:scoping} beschrieben, möglich sein, bestimmte Aufrufreihenfolgen festzulegen. Außerdem soll